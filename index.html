<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flexible Diagram Tool - v11</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Styles */
        svg { display: block; font-family: sans-serif; }
        #svg-container { border: 1px solid #ccc; min-height: 550px; overflow: auto; background-color: #e9e9e9; }
        .swimlane-rect { fill: #f9f9f9; stroke: #a0a0a0; stroke-width: 1; }
        .swimlane-label { font-size: 14px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; fill: #333; writing-mode: vertical-rl; text-orientation: mixed; }
        .actor-symbol { stroke: #333; stroke-width: 1.5; fill: none; stroke-linecap: round; }
        .actor-symbol circle { fill: #ffffff; }
        .element-label { font-size: 10px; fill: #333; text-anchor: middle; }
        .task-rect { fill: #ffffff; stroke: #666666; stroke-width: 1; rx: 5; ry: 5; }
        .task-text { font-size: 11px; fill: #000000; pointer-events: none; }
        .task-icon { fill: #666; stroke: none; }
        .event-circle { fill: #ffffff; stroke: #333; stroke-width: 1.5; }
        .event-circle-intermediate { fill: #ffffff; stroke: #333; stroke-width: 1; }
        .event-circle-end { fill: #ffffff; stroke: #333; stroke-width: 3px; }
        .event-circle-workflow-start { fill: #000000; stroke: #000000; stroke-width: 1.5; }
        .event-circle-workflow-end-outer { fill: none; stroke: #000000; stroke-width: 1.5; }
        .event-circle-workflow-end-middle { fill: #ffffff; stroke: none; }
        .event-circle-workflow-end-inner { fill: #000000; stroke: none; }
        .gateway-diamond { fill: #ffffff; stroke: #333; stroke-width: 1.5; transform-origin: center; }
        .gateway-marker { stroke: #333; stroke-width: 1.5; stroke-linecap: round; }
        .gateway-marker-inclusive { stroke: #333; stroke-width: 1.5; fill: none; }
        .syncbar-rect { fill: #000000; stroke: #000000; stroke-width: 1; }
        .connection-line { stroke: #333; stroke-width: 1.5; fill: none; marker-end: url(#arrowhead); }
        .connection-line-dashed { stroke: #333; stroke-width: 1.5; fill: none; marker-end: url(#arrowhead); stroke-dasharray: 5, 5; }
        .connection-label { font-size: 10px; fill: #444; text-anchor: middle; dominant-baseline: middle; }
        .connection-label-bg { fill: rgba(249, 249, 249, 0.9); rx: 2; ry: 2; }
        .context-box-rect { fill: #ffffff; stroke: #333; stroke-width: 1.5; }
        .context-box-label { font-size: 14px; font-weight: bold; fill: #000000; text-anchor: middle; dominant-baseline: middle; }
        .io-arrow { stroke: #333; stroke-width: 1.5; marker-end: url(#arrowhead); }
        .io-label { font-size: 10px; fill: #333; text-anchor: middle; dominant-baseline: middle; }
        .io-label-bg { fill: rgba(249, 249, 249, 0.9); rx: 2; ry: 2; }
        #error-message { color: #D8000C; font-family: monospace; white-space: pre-wrap; margin-top: 10px; padding: 10px; border: 1px solid #D8000C; border-radius: 5px; background-color: #FFD2D2; }
    </style>
</head>
<body class="bg-gray-100 p-8 font-sans">

    <h1 class="text-2xl font-bold mb-4 text-center text-gray-700">Flexible Diagram Tool (Increment 11)</h1>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
            <label for="markup-input" class="block text-sm font-medium text-gray-700 mb-1">Diagram Markup:</label>
            <textarea id="markup-input" rows="24" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Enter diagram markup here... (v11 syntax)"></textarea>
            <button id="render-button" class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md shadow focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                Render Diagram
            </button>
            <div id="error-message" class="mt-4 hidden"></div>
        </div>
        <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Generated Diagram:</label>
            <div id="svg-container" class="w-full bg-white rounded-md shadow-sm"></div>
        </div>
    </div>

     <div class="mt-8 p-4 bg-white rounded-md shadow-sm border border-gray-200">
         <h2 class="text-lg font-semibold mb-2 text-gray-800">Markup Syntax (v11)</h2>
         <p class="text-sm text-gray-600 mb-3">Refer to the v11 documentation artifact for the full syntax.</p>
         <h3 class="text-md font-semibold mt-4 mb-1 text-gray-700">Example:</h3>
         <pre class="bg-gray-50 p-3 rounded-md text-sm overflow-x-auto"><code>diagram SupplyChainExample

swimlane Suppliers "[Suppliers]" actor spacing=20 // Optional spacing
  task T1 "Accept Order" icon="envelope"
  task T2 "Prepare Goods" icon="gear"
end

swimlane Logistics "[Logistics]" actor // Default spacing
  task T4 "Arrange Supply" icon="user"
end

context C0 "Overall Supply Process"
    input "Customer Order Details" from=left
    output "Goods Delivered" to=right
    control "Quality Standards" from=top
    mechanism "Logistics System" from=bottom
endcontext

// Connections
connect T1 -> T2
connect T2 -> C0.bottom "Goods Info" style="dashed"
connect T4 -> C0.top "Supply Arrangement"
</code></pre>
    </div>


    <script>
        // --- Constants ---
        const SVG_PADDING = 30; const SWIMLANE_LABEL_WIDTH = 50; const SWIMLANE_PADDING_TOP = 40; const SWIMLANE_PADDING_BOTTOM = 30; const MIN_SWIMLANE_HEIGHT = 90; const TASK_WIDTH = 160; const TASK_HEIGHT = 70; const EVENT_RADIUS = 25; const GATEWAY_SIZE = 50; const ELEMENT_MARGIN_X = 50; const ELEMENT_MARGIN_Y = 20; const TEXT_LINE_HEIGHT = 14; const TEXT_PADDING_X = 5; const TEXT_PADDING_Y = 5; const LABEL_OFFSET_Y = 10; const ARROW_SIZE = 5;
        const CONNECTION_LABEL_OFFSET_Y = -8; const GATEWAY_MARKER_SCALE = 0.4; const WF_END_OUTER_RADIUS = EVENT_RADIUS; const WF_END_MIDDLE_RADIUS = EVENT_RADIUS * 0.8; const WF_END_INNER_RADIUS = EVENT_RADIUS * 0.6; const SYNCBAR_WIDTH_H = 80; const SYNCBAR_HEIGHT_H = 8; const SYNCBAR_WIDTH_V = 8; const SYNCBAR_HEIGHT_V = 80;
        const ACTOR_HEAD_RADIUS = 8; const ACTOR_BODY_HEIGHT = 18; const ACTOR_ARM_WIDTH = 20; const ACTOR_LEG_SPREAD = 10; const ACTOR_X_FACTOR = 0.3; const LABEL_X_FACTOR = 0.65;
        const CONTEXT_BOX_MARGIN_TOP = 40; const CONTEXT_BOX_HEIGHT = 80; const CONTEXT_BOX_WIDTH_FACTOR = 0.8; const IO_ARROW_LENGTH = 40;
        const IO_LABEL_OFFSET_Y_ON_ARROW = -5; const IO_LABEL_OFFSET_X_ON_ARROW = 5; const IO_ARROW_STAGGER_SPACING = 25;
        const IO_LABEL_HORIZONTAL_BUFFER = 50;
        const DEFAULT_SWIMLANE_SPACING = 15; // NEW: Default space between lanes
        const ICON_SIZE = 16; const ICON_PADDING = 4;
        // --- End Constants ---

        // --- Icon Path Data ---
        const ICON_PATHS = {
            // More standard looking paths (approximations)
            envelope: 'M3,4 H13 C13.55,4 14,4.45 14,5 V11 C14,11.55 13.55,12 13,12 H3 C2.45,12 2,11.55 2,11 V5 C2,4.45 2.45,4 3,4 Z M8,9 L13.5,5.5 M8,9 L2.5,5.5',
            user: 'M8,8 C9.1,8 10,7.1 10,6 C10,4.9 9.1,4 8,4 C6.9,4 6,4.9 6,6 C6,7.1 6.9,8 8,8 Z M8,9 C5.79,9 4,10.79 4,13 L12,13 C12,10.79 10.21,9 8,9 Z',
            gear: 'M13.7,8.7 L12.2,7.9 C12.1,7.6 12,7.3 11.8,7 L12,5.5 L10.5,4.7 L9.8,6 C9.5,5.9 9.2,5.8 8.9,5.8 L8.6,4 L7.4,4 L7.1,5.8 C6.8,5.8 6.5,5.9 6.2,6 L5.5,4.7 L4,5.5 L4.2,7 C4,7.3 3.9,7.6 3.8,7.9 L2.3,8.7 L2.3,10.3 L3.8,11.1 C3.9,11.4 4,11.7 4.2,12 L4,13.5 L5.5,14.3 L6.2,13 C6.5,13.1 6.8,13.2 7.1,13.2 L7.4,15 L8.6,15 L8.9,13.2 C9.2,13.2 9.5,13.1 9.8,13 L10.5,14.3 L12,13.5 L11.8,12 C12,11.7 12.1,11.4 12.2,11.1 L13.7,10.3 Z M8,11 C6.34,11 5,9.66 5,8 C5,6.34 6.34,5 8,5 C9.66,5 11,6.34 11,8 C11,9.66 9.66,11 8,11 Z',
            database: 'M8,2 C4.69,2 2,3.34 2,5 L2,11 C2,12.66 4.69,14 8,14 C11.31,14 14,12.66 14,11 L14,5 C14,3.34 11.31,2 8,2 Z M14,8 C14,9.66 11.31,11 8,11 C4.69,11 2,9.66 2,8 L2,5 M14,5 C14,6.66 11.31,8 8,8 C4.69,8 2,6.66 2,5',
            clock: 'M8,1 C4.13,1 1,4.13 1,8 C1,11.87 4.13,15 8,15 C11.87,15 15,11.87 15,8 C15,4.13 11.87,1 8,1 Z M9,8 L9,4 L7,4 L7,9 L11.5,11.5 L12.5,10.2 L9,8 Z'
        };
        const allowedIcons = Object.keys(ICON_PATHS);

        // --- DOM Elements ---
        const markupInput = document.getElementById('markup-input'); const renderButton = document.getElementById('render-button'); const svgContainer = document.getElementById('svg-container'); const errorMessageDiv = document.getElementById('error-message');

        // --- Data Structures ---
        /** @typedef {'task' | 'event' | 'gateway' | 'syncbar'} ElementShape */
        /** @typedef {'start' | 'end' | 'workflow-start' | 'workflow-end' | 'exclusive' | 'parallel' | 'generic' | 'horizontal' | 'vertical' | 'intermediate' | 'inclusive'} ElementSubtype */
        /** @typedef {'solid' | 'dashed'} ConnectionStyle */
        /** @typedef {'left' | 'right' | 'top' | 'bottom'} Side */
        /** @typedef {object} Point */
        /** @typedef {object} DiagramElement */
        /** @typedef {object} Swimlane */
        /** @typedef {object} Connection */
        /** @typedef {object} ContextIO */
        /** @typedef {object} ContextBox */
        /** @typedef {object} DiagramData */
         /** @typedef {object} Point */
        /** @typedef {object} DiagramElement */
        /** @typedef {object} Swimlane */
        /** @typedef {object} Connection */
        /** @typedef {object} ContextIO */
        /**
         * @typedef {object} ContextBox
         * @property {string} id
         * @property {string} label
         * @property {ContextIO[]} inputs
         * @property {ContextIO[]} outputs
         * @property {ContextIO[]} controls
         * @property {ContextIO[]} mechanisms
         * @property {number} [x], [y], [width], [height]
         */
         /** @typedef {object} DiagramData */
        /**
         * @typedef {object} DiagramData
         * @property {string | null} title
         * @property {Swimlane[]} swimlanes
         * @property {Connection[]} connections
         * @property {Map<string, DiagramElement>} elementMap
         * @property {ContextBox | null} contextBox
         */


        /** Parses the markup text v11 */
        function parseMarkup(markup) {
             const lines = markup.trim().split('\n');
             const data = { title: null, swimlanes: [], connections: [], elementMap: new Map(), contextBox: null };
             let currentSwimlane = null; let currentContextBox = null; let lineNumber = 0; let inSwimlane = false; let inContext = false; const definedElementIds = new Set(); const definedSwimlaneIds = new Set();

             // Regex declarations
             const diagramRegex = /^diagram\s+(.+)$/i;
             // Swimlane: Capture ID, Label, optional actor, optional spacing
             const swimlaneRegex = /^swimlane\s+([a-zA-Z0-9_-]+)\s+"([^"]+)"(?:\s+(actor))?(?:\s+spacing=(\d+))?\s*(?:[#\/\/].*)?$/i; // group 3 actor, group 4 spacing
             const taskRegex = /^task\s+([a-zA-Z0-9_-]+)\s+"([^"]+)"/; const iconRegex = /\bicon="([^"]+)"/i; const eventRegex = /^event\s+([a-zA-Z0-9_-]+)\s+"([^"]+)"(?:\s+type="([^"]+)")?\s*(?:[#\/\/].*)?$/i; const gatewayRegex = /^gateway\s+([a-zA-Z0-9_-]+)(?:\s+"([^"]+)")?(?:\s+type="([^"]+)")?\s*(?:[#\/\/].*)?$/i; const syncbarRegex = /^syncbar\s+([a-zA-Z0-9_-]+)(?:\s+orientation="([^"]+)")?\s*(?:[#\/\/].*)?$/i;
             // Connect Regexes (Element & Context) - Corrected context target
             const connectElementRegex = /^connect\s+([a-zA-Z0-9_-]+)\s*->\s*([a-zA-Z0-9_-]+)(?:\s+"([^"]+)")?(?:\s+style="([^"]+)")?\s*(?:[#\/\/].*)?$/i;
             const connectContextRegex = /^connect\s+([a-zA-Z0-9_-]+)\s*->\s*([a-zA-Z0-9_-]+)\.(top|bottom)(?:\s+"([^"]+)")?(?:\s+style="([^"]+)")?\s*(?:[#\/\/].*)?$/i; // Group 2=ContextID, Group 3=Side
             const connectInvalidContextRegex = /^connect\s+([a-zA-Z0-9_-]+)\s*->\s*([a-zA-Z0-9_-]+)\.([a-zA-Z]+)/i; // Check for invalid sides like left/right
             const endRegex = /^end\s*(?:[#\/\/].*)?$/i; const contextRegex = /^context\s+([a-zA-Z0-9_-]+)\s+"([^"]+)"\s*(?:[#\/\/].*)?$/i; const inputRegex = /^input\s+"([^"]+)"\s+from=([a-zA-Z]+)\s*(?:[#\/\/].*)?$/i; const outputRegex = /^output\s+"([^"]+)"\s+to=([a-zA-Z]+)\s*(?:[#\/\/].*)?$/i; const controlRegex = /^control\s+"([^"]+)"\s+from=([a-zA-Z]+)\s*(?:[#\/\/].*)?$/i; const mechanismRegex = /^mechanism\s+"([^"]+)"\s+from=([a-zA-Z]+)\s*(?:[#\/\/].*)?$/i; const endContextRegex = /^endcontext\s*(?:[#\/\/].*)?$/i;

             const allowedEventTypes = ['start', 'end', 'workflow-start', 'workflow-end', 'intermediate']; const allowedGatewayTypes = ['exclusive', 'parallel', 'inclusive']; const allowedSyncOrientations = ['horizontal', 'vertical']; const allowedConnectionStyles = ['solid', 'dashed']; const allowedInputSides = ['left']; const allowedOutputSides = ['right']; const allowedControlSides = ['top']; const allowedMechanismSides = ['bottom'];

             for (const rawLine of lines) { lineNumber++; const line = rawLine.trim(); if (!line || line.startsWith('//') || line.startsWith('#')) continue;
                 try { let processed = false; if (inContext) { const inputMatch = line.match(inputRegex); const outputMatch = line.match(outputRegex); const controlMatch = line.match(controlRegex); const mechanismMatch = line.match(mechanismRegex); const endContextMatch = line.match(endContextRegex); if (inputMatch && currentContextBox) { const [, label, side] = inputMatch; const lowerSide = side.toLowerCase(); if (!allowedInputSides.includes(lowerSide)) throw new Error(`Invalid input side: '${side}'. Allowed: ${allowedInputSides.join(', ')}.`); currentContextBox.inputs.push({ label, side: lowerSide }); processed = true; } else if (outputMatch && currentContextBox) { const [, label, side] = outputMatch; const lowerSide = side.toLowerCase(); if (!allowedOutputSides.includes(lowerSide)) throw new Error(`Invalid output side: '${side}'. Allowed: ${allowedOutputSides.join(', ')}.`); currentContextBox.outputs.push({ label, side: lowerSide }); processed = true; } else if (controlMatch && currentContextBox) { const [, label, side] = controlMatch; const lowerSide = side.toLowerCase(); if (!allowedControlSides.includes(lowerSide)) throw new Error(`Invalid control side: '${side}'. Allowed: ${allowedControlSides.join(', ')}.`); currentContextBox.controls.push({ label, side: lowerSide }); processed = true; } else if (mechanismMatch && currentContextBox) { const [, label, side] = mechanismMatch; const lowerSide = side.toLowerCase(); if (!allowedMechanismSides.includes(lowerSide)) throw new Error(`Invalid mechanism side: '${side}'. Allowed: ${allowedMechanismSides.join(', ')}.`); currentContextBox.mechanisms.push({ label, side: lowerSide }); processed = true; } else if (endContextMatch) { currentContextBox = null; inContext = false; processed = true; } else { if (line.match(contextRegex)) throw new Error("Cannot nest context blocks."); if (line.match(swimlaneRegex)) throw new Error("Cannot define swimlane inside context block."); } } else if (inSwimlane) { const taskMatch = line.match(taskRegex); const eventMatch = line.match(eventRegex); const gatewayMatch = line.match(gatewayRegex); const syncbarMatch = line.match(syncbarRegex); const endMatch = line.match(endRegex); if (taskMatch && currentSwimlane) { const [, id, description] = taskMatch; if (definedElementIds.has(id)) throw new Error(`Duplicate element ID: '${id}'.`); let iconName = null; const iconMatch = iconRegex.exec(line.substring(taskMatch[0].length)); if (iconMatch) { const potentialIcon = iconMatch[1].toLowerCase(); if (allowedIcons.includes(potentialIcon)) { iconName = potentialIcon; } else { throw new Error(`Invalid icon name: '${iconMatch[1]}'. Allowed: ${allowedIcons.join(', ')}.`); } } currentSwimlane.elements.push({ id, shape: 'task', type: 'generic', label: description, iconName }); definedElementIds.add(id); processed = true; } else if (eventMatch && currentSwimlane) { const [, id, label, typeInput] = eventMatch; if (definedElementIds.has(id)) throw new Error(`Duplicate element ID: '${id}'.`); let elementType = 'start'; if (typeInput) { const lt = typeInput.toLowerCase(); if (allowedEventTypes.includes(lt)) elementType = lt; else throw new Error(`Invalid event type: '${typeInput}'. Allowed: ${allowedEventTypes.join(', ')}.`); } currentSwimlane.elements.push({ id, shape: 'event', type: elementType, label, iconName: null }); definedElementIds.add(id); processed = true; } else if (gatewayMatch && currentSwimlane) { const [, id, labelInput, typeInput] = gatewayMatch; if (definedElementIds.has(id)) throw new Error(`Duplicate element ID: '${id}'.`); let gatewayType = 'exclusive'; if (typeInput) { const lt = typeInput.toLowerCase(); if (allowedGatewayTypes.includes(lt)) gatewayType = lt; else throw new Error(`Invalid gateway type: '${typeInput}'. Allowed: ${allowedGatewayTypes.join(', ')}.`); } currentSwimlane.elements.push({ id, shape: 'gateway', type: gatewayType, label: labelInput || null, iconName: null }); definedElementIds.add(id); processed = true; } else if (syncbarMatch && currentSwimlane) { const [, id, orientationInput] = syncbarMatch; if (definedElementIds.has(id)) throw new Error(`Duplicate element ID: '${id}'.`); let orientation = 'horizontal'; if (orientationInput) { const lo = orientationInput.toLowerCase(); if (allowedSyncOrientations.includes(lo)) orientation = lo; else throw new Error(`Invalid syncbar orientation: '${orientationInput}'. Allowed: ${allowedSyncOrientations.join(', ')}.`); } currentSwimlane.elements.push({ id, shape: 'syncbar', type: orientation, label: null, iconName: null }); definedElementIds.add(id); processed = true; } else if (endMatch) { currentSwimlane = null; inSwimlane = false; processed = true; } else { if (line.match(swimlaneRegex)) throw new Error("Cannot start swimlane inside another."); if (line.match(connectRegex)) throw new Error("Cannot define connections inside swimlane."); if (line.match(diagramRegex)) throw new Error("Cannot define diagram title inside swimlane."); if (line.match(contextRegex)) throw new Error("Cannot define context inside swimlane.");} } else { const diagramMatch = line.match(diagramRegex); const swimlaneMatch = line.match(swimlaneRegex); const connectElementMatch = line.match(connectElementRegex); const connectContextMatch = line.match(connectContextRegex); const connectInvalidContextMatch = line.match(connectInvalidContextRegex); const contextMatch = line.match(contextRegex); if (diagramMatch && !data.title) { data.title = diagramMatch[1].trim(); processed = true; } else if (swimlaneMatch) {
                         const [, id, label, actorKeyword, spacingInput] = swimlaneMatch; // group 4 spacing
                         if (definedSwimlaneIds.has(id)) throw new Error(`Duplicate swimlane ID: '${id}'.`);
                         definedSwimlaneIds.add(id);
                         const hasActor = !!actorKeyword && actorKeyword.toLowerCase() === 'actor';
                         let spacingBelow = DEFAULT_SWIMLANE_SPACING; // Use default
                         if (spacingInput) {
                             const spacingVal = parseInt(spacingInput, 10);
                             if (!isNaN(spacingVal) && spacingVal >= 0) {
                                 spacingBelow = spacingVal;
                             } else {
                                 throw new Error(`Invalid spacing value: '${spacingInput}'. Must be a non-negative integer.`);
                             }
                         }
                         currentSwimlane = { id, label, hasActor, elements: [], spacingBelow }; // Store spacing
                         data.swimlanes.push(currentSwimlane); inSwimlane = true; processed = true;
                     } else if (connectElementMatch) { const [, sourceId, targetId, label, styleInput] = connectElementMatch; let style = 'solid'; if (styleInput) { const ls = styleInput.toLowerCase(); if (allowedConnectionStyles.includes(ls)) style = ls; else throw new Error(`Invalid connection style: '${styleInput}'.`); } data.connections.push({ sourceId, targetId, targetType: 'element', targetSide: null, label: label || null, style, lineNumber }); processed = true;
                     } else if (connectContextMatch) {
                         const [, sourceId, targetContextId, targetSide, label, styleInput] = connectContextMatch;
                         // Validation moved to post-parsing
                         let style = 'solid'; if (styleInput) { const ls = styleInput.toLowerCase(); if (allowedConnectionStyles.includes(ls)) style = ls; else throw new Error(`Invalid connection style: '${styleInput}'.`); }
                         data.connections.push({ sourceId, targetId: targetContextId, targetType: 'context', targetSide: targetSide.toLowerCase(), label: label || null, style, lineNumber }); // Store context ID temporarily in targetId
                         processed = true;
                     } else if (connectInvalidContextMatch) { // Check for invalid context connection *after* valid ones
                        const [, , , targetSide] = connectInvalidContextMatch;
                        throw new Error(`Invalid target context side '${targetSide}'. Only context.top and context.bottom allowed for task connections.`);
                     }
                      else if (contextMatch) { if (data.contextBox) throw new Error("Only one context block allowed per diagram."); const [, id, label] = contextMatch; currentContextBox = { id, label, inputs: [], outputs: [], controls: [], mechanisms: [] }; data.contextBox = currentContextBox; inContext = true; processed = true; }
                      else { if (line.match(endRegex)) throw new Error("'end' found outside swimlane block."); if (line.match(taskRegex) || line.match(eventRegex) || line.match(gatewayRegex) || line.match(syncbarRegex)) throw new Error("Element definition must be inside swimlane block."); if (line.match(endContextRegex)) throw new Error("'endcontext' found outside context block."); if (line.match(inputRegex) || line.match(outputRegex) || line.match(controlRegex) || line.match(mechanismRegex)) throw new Error("Context I/O/C/M definition must be inside context block.");} }
                     if (!processed) { if (line.toLowerCase().startsWith('control')) throw new Error('Invalid control syntax or placement.'); if (line.toLowerCase().startsWith('mechanism')) throw new Error('Invalid mechanism syntax or placement.'); if (line.toLowerCase().startsWith('context')) throw new Error('Invalid context syntax or placement.'); if (line.toLowerCase().startsWith('input')) throw new Error('Invalid input syntax or placement.'); if (line.toLowerCase().startsWith('output')) throw new Error('Invalid output syntax or placement.'); if (line.toLowerCase().startsWith('endcontext')) throw new Error('Invalid endcontext syntax or placement.'); if (line.toLowerCase().startsWith('syncbar')) throw new Error('Invalid syncbar syntax or placement.'); if (line.toLowerCase().startsWith('swimlane')) throw new Error('Invalid swimlane syntax or placement.'); if (line.toLowerCase().startsWith('task')) throw new Error('Invalid task syntax or placement.'); if (line.toLowerCase().startsWith('event')) throw new Error('Invalid event syntax or placement.'); if (line.toLowerCase().startsWith('gateway')) throw new Error('Invalid gateway syntax or placement.'); if (line.toLowerCase().startsWith('connect')) throw new Error('Invalid connect syntax or placement.'); if (line.toLowerCase().startsWith('end')) throw new Error('Invalid end syntax or placement.'); if (line.toLowerCase().startsWith('diagram')) throw new Error('Invalid diagram syntax or placement.'); throw new Error(`Unknown or invalid syntax.`); }
                 } catch (e) { const context = inContext? 'inside context block' : (inSwimlane ? `inside swimlane '${currentSwimlane?.id || '?'}'` : "top level"); const message = e.message.includes(`line ${lineNumber}`) ? e.message : `Error on line ${lineNumber} (${context}): ${e.message}`; return { data: null, error: message }; }
             } // End loop
             if (inSwimlane) return { data: null, error: `Error: Reached end of input, but swimlane '${currentSwimlane?.id}' was not closed with 'end'.` }; if (inContext) return { data: null, error: `Error: Reached end of input, but context block was not closed with 'endcontext'.` };
             // Post-Parsing Validation
             for (const conn of data.connections) {
                 if (!definedElementIds.has(conn.sourceId)) return { data: null, error: `Error on line ${conn.lineNumber}: Source element ID '${conn.sourceId}' does not exist.` };
                 if (conn.targetType === 'element') {
                     if (!definedElementIds.has(conn.targetId)) return { data: null, error: `Error on line ${conn.lineNumber}: Target element ID '${conn.targetId}' does not exist.` };
                 } else if (conn.targetType === 'context') {
                     if (!data.contextBox) return { data: null, error: `Error on line ${conn.lineNumber}: Target 'context.${conn.targetSide}' specified, but no context block defined.`};
                     // FIX: Validate context ID match and allowed sides
                     if (data.contextBox.id !== conn.targetId) return { data: null, error: `Error on line ${conn.lineNumber}: Target context ID '${conn.targetId}' does not match defined context ID '${data.contextBox.id}'.`};
                     if (!(conn.targetSide === 'top' || conn.targetSide === 'bottom')) return { data: null, error: `Error on line ${conn.lineNumber}: Invalid target context side '${conn.targetSide}'. Only context.top and context.bottom allowed for task connections.`};
                     // Clear targetId after validation as it's not an element ID
                     conn.targetId = null;
                 }
             }
             return { data, error: null };
        }

        /** Wraps text */
        function wrapText(text, maxWidth) {
             const avgCharWidth = 6; const charsPerLine = Math.max(5, Math.floor(maxWidth / avgCharWidth)); const words = text.split(/(\s+)/); const lines = []; let currentLine = ''; for (const word of words) { if (!word) continue; const potentialLine = currentLine ? currentLine + word : word; if (potentialLine.length <= charsPerLine) { currentLine = potentialLine; } else { if (currentLine) lines.push(currentLine); if (word.trim().length > charsPerLine) { let remainingWord = word.trim(); while(remainingWord.length > charsPerLine) { lines.push(remainingWord.substring(0, charsPerLine)); remainingWord = remainingWord.substring(charsPerLine); } currentLine = remainingWord; } else { currentLine = word.trim(); } } } if (currentLine) lines.push(currentLine); return lines;
        }

        /** Calculates connection points */
        function getBestConnectionPoints(sourceElement, targetElement) {
            const sourceConnectE = sourceElement.connectE; const sourceConnectW = sourceElement.connectW; const targetConnectE = targetElement.connectE; const targetConnectW = targetElement.connectW; const sourceConnectN = sourceElement.connectN; const sourceConnectS = sourceElement.connectS; const targetConnectN = targetElement.connectN; const targetConnectS = targetElement.connectS;
            let sourcePoint = sourceConnectE; let targetPoint = targetConnectW;
            if (targetElement.cx < sourceElement.cx - sourceElement.width / 2) { sourcePoint = sourceConnectW; targetPoint = targetConnectE; }
            else if (targetElement.cy < sourceElement.cy - sourceElement.height / 1.5) { sourcePoint = sourceConnectN; targetPoint = targetConnectS; }
            else if (targetElement.cy > sourceElement.cy + sourceElement.height / 1.5) { sourcePoint = sourceConnectS; targetPoint = targetConnectN; }
            else if (Math.abs(targetElement.cy - sourceElement.cy) < sourceElement.height / 1.5) { if (targetElement.cx > sourceElement.cx) { sourcePoint = sourceConnectE; targetPoint = targetConnectW; } else { sourcePoint = sourceConnectW; targetPoint = targetConnectE; } }
            else if (targetElement.cx <= sourceElement.cx) { sourcePoint = sourceConnectW; targetPoint = targetConnectE; }
            return { sourcePoint, targetPoint };
        }

        /** Renders the diagram */
        function renderDiagram(data, svg) {
             svg.innerHTML = ''; const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs'); const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker'); marker.setAttribute('id', 'arrowhead'); marker.setAttribute('markerWidth', ARROW_SIZE * 2); marker.setAttribute('markerHeight', ARROW_SIZE * 1.5); marker.setAttribute('refX', ARROW_SIZE); marker.setAttribute('refY', ARROW_SIZE * 0.75); marker.setAttribute('orient', 'auto-start-reverse'); const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); polygon.setAttribute('points', `0 0, ${ARROW_SIZE * 2} ${ARROW_SIZE * 0.75}, 0 ${ARROW_SIZE * 1.5}`); polygon.setAttribute('fill', '#333'); marker.appendChild(polygon); defs.appendChild(marker); svg.appendChild(defs);
             let currentY = SVG_PADDING; let maxSwimlaneContentWidth = 0; data.elementMap.clear();

             // Calculate Layout (Phase 1 - Swimlanes/Elements)
             data.swimlanes.forEach((swimlane, laneIndex) => {
                 swimlane.y = currentY; let elementX = SVG_PADDING + SWIMLANE_LABEL_WIDTH + ELEMENT_MARGIN_X / 2; let maxElementHeightInLane = 0; let currentLaneWidth = 0;
                 swimlane.elements.forEach((element, index) => { element.x = elementX; element.y = currentY + SWIMLANE_PADDING_TOP; switch (element.shape) { case 'task': element.width = TASK_WIDTH; const textLines = wrapText(element.label || '', TASK_WIDTH - 2 * TEXT_PADDING_X - (element.iconName ? ICON_SIZE + ICON_PADDING : 0)); element.height = Math.max(TASK_HEIGHT, textLines.length * TEXT_LINE_HEIGHT + 2 * TEXT_PADDING_Y + TEXT_PADDING_Y); break; case 'event': element.width = EVENT_RADIUS * 2; element.height = EVENT_RADIUS * 2; break; case 'gateway': element.width = GATEWAY_SIZE; element.height = GATEWAY_SIZE; break; case 'syncbar': if (element.type === 'vertical') { element.width = SYNCBAR_WIDTH_V; element.height = SYNCBAR_HEIGHT_V; } else { element.width = SYNCBAR_WIDTH_H; element.height = SYNCBAR_HEIGHT_H; } break; } element.cx = element.x + element.width / 2; element.cy = element.y + element.height / 2; element.connectN = { x: element.cx, y: element.y }; element.connectS = { x: element.cx, y: element.y + element.height }; element.connectE = { x: element.x + element.width, y: element.cy }; element.connectW = { x: element.x, y: element.cy }; elementX += element.width + ELEMENT_MARGIN_X; let totalHeight = element.height; if ((element.shape === 'event' || element.shape === 'gateway') && element.label) { totalHeight += TEXT_LINE_HEIGHT + LABEL_OFFSET_Y; } maxElementHeightInLane = Math.max(maxElementHeightInLane, totalHeight); data.elementMap.set(element.id, element); }); if (swimlane.elements.length > 0) { const lastElement = swimlane.elements[swimlane.elements.length - 1]; currentLaneWidth = (lastElement.x + lastElement.width) - (swimlane.elements[0].x); } else { currentLaneWidth = 0; } maxSwimlaneContentWidth = Math.max(maxSwimlaneContentWidth, currentLaneWidth); const calculatedHeightBasedOnContent = SWIMLANE_PADDING_TOP + maxElementHeightInLane + SWIMLANE_PADDING_BOTTOM; swimlane.height = Math.max(MIN_SWIMLANE_HEIGHT, calculatedHeightBasedOnContent);
                 // Use specified spacing or default
                 currentY += swimlane.height + (swimlane.spacingBelow !== undefined ? swimlane.spacingBelow : DEFAULT_SWIMLANE_SPACING);
             });
             // Adjust currentY after loop
             if (data.swimlanes.length > 0) {
                 const lastLane = data.swimlanes[data.swimlanes.length - 1];
                 currentY -= (lastLane.spacingBelow !== undefined ? lastLane.spacingBelow : DEFAULT_SWIMLANE_SPACING);
             }

             // Calculate Layout (Phase 2 - Context Box)
             let contextBoxTotalHeight = 0; let swimlaneBlockBottom = currentY;
             let diagramContentWidth = SWIMLANE_LABEL_WIDTH + ELEMENT_MARGIN_X + maxSwimlaneContentWidth;
             if (data.contextBox) { const contextBoxWidth = diagramContentWidth * CONTEXT_BOX_WIDTH_FACTOR; const contextBoxX = SVG_PADDING + SWIMLANE_LABEL_WIDTH + ELEMENT_MARGIN_X / 2 + (maxSwimlaneContentWidth * (1 - CONTEXT_BOX_WIDTH_FACTOR) / 2); const contextBoxY = swimlaneBlockBottom + CONTEXT_BOX_MARGIN_TOP; data.contextBox.x = contextBoxX; data.contextBox.y = contextBoxY; data.contextBox.width = contextBoxWidth; data.contextBox.height = CONTEXT_BOX_HEIGHT; contextBoxTotalHeight = CONTEXT_BOX_MARGIN_TOP + CONTEXT_BOX_HEIGHT + SVG_PADDING; } else { contextBoxTotalHeight = SVG_PADDING; }
             const totalContentWidth = SVG_PADDING + diagramContentWidth + SVG_PADDING + IO_LABEL_HORIZONTAL_BUFFER * 2;
             const totalDiagramHeight = swimlaneBlockBottom + contextBoxTotalHeight; svg.setAttribute('viewBox', `0 0 ${totalContentWidth} ${totalDiagramHeight}`); svg.setAttribute('width', '100%');

             // Render Swimlanes & Elements
             const swimlaneRenderWidth = totalContentWidth - 2 * SVG_PADDING;
             data.swimlanes.forEach((swimlane, laneIndex) => {
                 const laneRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); laneRect.setAttribute('x', SVG_PADDING); laneRect.setAttribute('y', swimlane.y); laneRect.setAttribute('width', swimlaneRenderWidth); laneRect.setAttribute('height', swimlane.height); laneRect.setAttribute('class', 'swimlane-rect'); svg.appendChild(laneRect);
                 if (laneIndex > 0) { const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', SVG_PADDING); line.setAttribute('y1', swimlane.y); line.setAttribute('x2', SVG_PADDING + swimlaneRenderWidth); line.setAttribute('y2', swimlane.y); line.setAttribute('stroke', '#a0a0a0'); line.setAttribute('stroke-width', 1); svg.appendChild(line); }
                 const labelAreaBaseX = SVG_PADDING; const labelAreaCenterY = swimlane.y + swimlane.height / 2; let labelTextX = labelAreaBaseX + SWIMLANE_LABEL_WIDTH / 2; let labelTextY = labelAreaCenterY;
                 if (swimlane.hasActor) { const actorCenterX = labelAreaBaseX + SWIMLANE_LABEL_WIDTH * ACTOR_X_FACTOR; const actorCenterY = labelAreaCenterY - 5; drawActorSymbol(actorCenterX, actorCenterY, svg); labelTextX = labelAreaBaseX + SWIMLANE_LABEL_WIDTH * LABEL_X_FACTOR; labelTextY = labelAreaCenterY; }
                 const laneLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text'); laneLabel.setAttribute('x', labelTextX); laneLabel.setAttribute('y', labelTextY); laneLabel.setAttribute('class', 'swimlane-label'); laneLabel.setAttribute('dominant-baseline', 'middle'); laneLabel.textContent = swimlane.label; svg.appendChild(laneLabel);
                 swimlane.elements.forEach(element => { switch (element.shape) { case 'task': drawTask(element, svg); break; case 'event': drawEvent(element, svg); break; case 'gateway': drawGateway(element, svg); break; case 'syncbar': drawSyncBar(element, svg); break; } if ((element.shape === 'event' || element.shape === 'gateway') && element.label) { const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text'); labelText.setAttribute('x', element.cx); labelText.setAttribute('y', element.y + element.height + LABEL_OFFSET_Y); labelText.setAttribute('class', 'element-label'); labelText.textContent = element.label; svg.appendChild(labelText); } });
             });

             // Render Connections (Element-to-Element and Task-to-Context)
             const contextTopTargetCounts = {}; const contextBottomTargetCounts = {};
             data.connections.filter(conn => conn.targetType === 'context').forEach(conn => { const sourceElement = data.elementMap.get(conn.sourceId); if (!sourceElement) return; const targetXEstimate = sourceElement.cx; if (conn.targetSide === 'top') { contextTopTargetCounts[targetXEstimate] = (contextTopTargetCounts[targetXEstimate] || 0) + 1; } else if (conn.targetSide === 'bottom') { contextBottomTargetCounts[targetXEstimate] = (contextBottomTargetCounts[targetXEstimate] || 0) + 1; } });
             let currentTopIndices = {}; let currentBottomIndices = {};

             data.connections.forEach(conn => {
                 const sourceElement = data.elementMap.get(conn.sourceId); if (!sourceElement) return;
                 let targetPoint; let targetElement = null;
                 if (conn.targetType === 'element') { targetElement = data.elementMap.get(conn.targetId); if (!targetElement) return; const points = getBestConnectionPoints(sourceElement, targetElement); targetPoint = points.targetPoint; }
                 else if (conn.targetType === 'context' && data.contextBox) { const cb = data.contextBox; const boxCenterX = cb.x + cb.width / 2; const targetXEstimate = sourceElement.cx; let targetX, targetY, count, currentIndex; if (conn.targetSide === 'top') { targetY = cb.y; count = contextTopTargetCounts[targetXEstimate] || 1; currentIndex = currentTopIndices[targetXEstimate] || 0; targetX = boxCenterX + (currentIndex - (count - 1) / 2) * IO_ARROW_STAGGER_SPACING; currentTopIndices[targetXEstimate] = currentIndex + 1; } else if (conn.targetSide === 'bottom') { targetY = cb.y + cb.height; count = contextBottomTargetCounts[targetXEstimate] || 1; currentIndex = currentBottomIndices[targetXEstimate] || 0; targetX = boxCenterX + (currentIndex - (count - 1) / 2) * IO_ARROW_STAGGER_SPACING; currentBottomIndices[targetXEstimate] = currentIndex + 1; } else { return; } targetPoint = { x: targetX, y: targetY }; }
                 else { return; }
                 const { sourcePoint } = getBestConnectionPoints(sourceElement, targetElement || { cx: targetPoint.x, cy: targetPoint.y, width: 0, height: 0 });
                 const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                 let pathData = `M ${sourcePoint.x} ${sourcePoint.y}`; let labelPos = { x: (sourcePoint.x + targetPoint.x) / 2, y: (sourcePoint.y + targetPoint.y) / 2 }; const dx = targetPoint.x - sourcePoint.x; const dy = targetPoint.y - sourcePoint.y;
                 let endX = targetPoint.x; let endY = targetPoint.y; let isLastSegmentHorizontal = Math.abs(dx) > Math.abs(dy);
                 if (isLastSegmentHorizontal) { endX = targetPoint.x - Math.sign(dx) * ARROW_SIZE; const midX = sourcePoint.x + dx / 2; pathData += ` H ${midX} V ${targetPoint.y} H ${endX}`; labelPos = { x: midX, y: (sourcePoint.y + targetPoint.y) / 2 }; }
                 else { endY = targetPoint.y - Math.sign(dy) * ARROW_SIZE; const midY = sourcePoint.y + dy / 2; pathData += ` V ${midY} H ${targetPoint.x} V ${endY}`; labelPos = { x: (sourcePoint.x + targetPoint.x) / 2, y: midY }; }
                 path.setAttribute('d', pathData); path.setAttribute('class', conn.style === 'dashed' ? 'connection-line-dashed' : 'connection-line'); svg.appendChild(path);
                 if (conn.label) { const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text'); labelText.setAttribute('x', labelPos.x); labelText.setAttribute('y', labelPos.y + CONNECTION_LABEL_OFFSET_Y); labelText.setAttribute('class', 'connection-label'); labelText.textContent = conn.label; const approxLabelWidth = conn.label.length * 5.5; const approxLabelHeight = 12; const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); labelBg.setAttribute('x', labelPos.x - approxLabelWidth / 2 - 2); labelBg.setAttribute('y', labelPos.y + CONNECTION_LABEL_OFFSET_Y - approxLabelHeight / 2 - 1); labelBg.setAttribute('width', approxLabelWidth + 4); labelBg.setAttribute('height', approxLabelHeight + 2); labelBg.setAttribute('class', 'connection-label-bg'); svg.appendChild(labelBg); svg.appendChild(labelText); }
             });

             // Render Context Box & I/O Arrows (Arrows FROM context)
             if (data.contextBox) {
                 const cb = data.contextBox;
                 const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); rect.setAttribute('x', cb.x); rect.setAttribute('y', cb.y); rect.setAttribute('width', cb.width); rect.setAttribute('height', cb.height); rect.setAttribute('class', 'context-box-rect'); svg.appendChild(rect);
                 const label = document.createElementNS('http://www.w3.org/2000/svg', 'text'); label.setAttribute('x', cb.x + cb.width / 2); label.setAttribute('y', cb.y + cb.height / 2); label.setAttribute('class', 'context-box-label'); label.textContent = cb.label; svg.appendChild(label);

                 const boxCenterY = cb.y + cb.height / 2;
                 const boxCenterX = cb.x + cb.width / 2;

                 // Draw I/O/C/M Arrows with labels ON arrows
                 [...cb.inputs, ...cb.outputs, ...cb.controls, ...cb.mechanisms].forEach(io => {
                    let startX, startY, endX, endY;
                    let labelOffsetX = IO_LABEL_OFFSET_X_ON_ARROW; let labelOffsetY = IO_LABEL_OFFSET_Y_ON_ARROW;

                    if (io.side === 'left') { startX = cb.x - IO_ARROW_LENGTH; startY = boxCenterY; endX = cb.x; endY = startY; labelOffsetX = 0;}
                    else if (io.side === 'right') { startX = cb.x + cb.width; startY = boxCenterY; endX = startX + IO_ARROW_LENGTH; endY = startY; labelOffsetX = 0;}
                    else if (io.side === 'top') { startX = boxCenterX; startY = cb.y - IO_ARROW_LENGTH; endX = startX; endY = cb.y; labelOffsetY = 0;}
                    else if (io.side === 'bottom') { startX = boxCenterX; startY = cb.y + cb.height + IO_ARROW_LENGTH; endX = startX; endY = cb.y + cb.height; labelOffsetY = 0;}
                    else { return; }

                    drawIoArrow(startX, startY, endX, endY, io.label, io.side, labelOffsetX, labelOffsetY, svg);
                 });
             }

             // Render Title
             if (data.title) { const titleText = document.createElementNS('http://www.w3.org/2000/svg', 'text'); titleText.setAttribute('x', totalContentWidth / 2); titleText.setAttribute('y', SVG_PADDING / 1.5); titleText.setAttribute('text-anchor', 'middle'); titleText.setAttribute('font-size', '18px'); titleText.setAttribute('font-weight', 'bold'); titleText.setAttribute('fill', '#333'); titleText.textContent = data.title; svg.appendChild(titleText); }
        }

        // --- Drawing Functions ---
        function drawTask(element, svg) {
             const taskRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); taskRect.setAttribute('x', element.x); taskRect.setAttribute('y', element.y); taskRect.setAttribute('width', element.width); taskRect.setAttribute('height', element.height); taskRect.setAttribute('class', 'task-rect'); svg.appendChild(taskRect);
             if (element.iconName && ICON_PATHS[element.iconName]) {
                 const iconSize = ICON_SIZE; const iconPadding = ICON_PADDING; const iconX = element.x + iconPadding; const iconY = element.y + iconPadding; const iconPath = document.createElementNS('http://www.w3.org/2000/svg', 'path'); iconPath.setAttribute('d', ICON_PATHS[element.iconName]); iconPath.setAttribute('transform', `translate(${iconX}, ${iconY}) scale(${iconSize / 16})`); iconPath.setAttribute('class', 'task-icon'); svg.appendChild(iconPath);
                 const textStartX = element.x + iconPadding + iconSize + TEXT_PADDING_X; const textWidth = element.width - (iconPadding + iconSize + TEXT_PADDING_X + TEXT_PADDING_X); const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text'); textElement.setAttribute('x', textStartX); textElement.setAttribute('y', element.y + TEXT_PADDING_Y + TEXT_LINE_HEIGHT * 0.8); textElement.setAttribute('class', 'task-text'); const textLines = wrapText(element.label || '', textWidth); textLines.forEach((line, index) => { const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan'); tspan.setAttribute('x', textStartX); tspan.setAttribute('dy', index === 0 ? 0 : TEXT_LINE_HEIGHT); tspan.textContent = line; textElement.appendChild(tspan); }); svg.appendChild(textElement);
             } else {
                 const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text'); textElement.setAttribute('x', element.x + TEXT_PADDING_X); textElement.setAttribute('y', element.y + TEXT_PADDING_Y + TEXT_LINE_HEIGHT * 0.8); textElement.setAttribute('class', 'task-text'); const textLines = wrapText(element.label || '', element.width - 2 * TEXT_PADDING_X); textLines.forEach((line, index) => { const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan'); tspan.setAttribute('x', element.x + TEXT_PADDING_X); tspan.setAttribute('dy', index === 0 ? 0 : TEXT_LINE_HEIGHT); tspan.textContent = line; textElement.appendChild(tspan); }); svg.appendChild(textElement);
             }
        }
        function drawEvent(element, svg) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g'); let circleClass = 'event-circle'; switch (element.type) { case 'end': circleClass = 'event-circle-end'; const circleEnd = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); circleEnd.setAttribute('cx', element.cx); circleEnd.setAttribute('cy', element.cy); circleEnd.setAttribute('r', EVENT_RADIUS); circleEnd.setAttribute('class', circleClass); group.appendChild(circleEnd); break; case 'workflow-start': circleClass = 'event-circle-workflow-start'; const circleWFS = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); circleWFS.setAttribute('cx', element.cx); circleWFS.setAttribute('cy', element.cy); circleWFS.setAttribute('r', EVENT_RADIUS); circleWFS.setAttribute('class', circleClass); group.appendChild(circleWFS); break; case 'workflow-end': const outer = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); outer.setAttribute('cx', element.cx); outer.setAttribute('cy', element.cy); outer.setAttribute('r', WF_END_OUTER_RADIUS); outer.setAttribute('class', 'event-circle-workflow-end-outer'); group.appendChild(outer); const middle = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); middle.setAttribute('cx', element.cx); middle.setAttribute('cy', element.cy); middle.setAttribute('r', WF_END_MIDDLE_RADIUS); middle.setAttribute('class', 'event-circle-workflow-end-middle'); group.appendChild(middle); const inner = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); inner.setAttribute('cx', element.cx); inner.setAttribute('cy', element.cy); inner.setAttribute('r', WF_END_INNER_RADIUS); inner.setAttribute('class', 'event-circle-workflow-end-inner'); group.appendChild(inner); break; case 'start': default: const circleStart = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); circleStart.setAttribute('cx', element.cx); circleStart.setAttribute('cy', element.cy); circleStart.setAttribute('r', EVENT_RADIUS); circleStart.setAttribute('class', circleClass); group.appendChild(circleStart); break; } svg.appendChild(group);
        }
        function drawGateway(element, svg) {
             const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); const halfW = element.width / 2; const halfH = element.height / 2; const points = [[element.cx, element.y], [element.x + element.width, element.cy], [element.cx, element.y + element.height], [element.x, element.cy]].map(p => p.join(',')).join(' '); diamond.setAttribute('points', points); diamond.setAttribute('class', 'gateway-diamond'); svg.appendChild(diamond); const markerSize = element.width * GATEWAY_MARKER_SCALE; const markerHalf = markerSize / 2; if (element.type === 'exclusive') { const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line1.setAttribute('x1', element.cx - markerHalf); line1.setAttribute('y1', element.cy - markerHalf); line1.setAttribute('x2', element.cx + markerHalf); line1.setAttribute('y2', element.cy + markerHalf); line1.setAttribute('class', 'gateway-marker'); svg.appendChild(line1); const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line2.setAttribute('x1', element.cx + markerHalf); line2.setAttribute('y1', element.cy - markerHalf); line2.setAttribute('x2', element.cx - markerHalf); line2.setAttribute('y2', element.cy + markerHalf); line2.setAttribute('class', 'gateway-marker'); svg.appendChild(line2); } else if (element.type === 'parallel') { const lineH = document.createElementNS('http://www.w3.org/2000/svg', 'line'); lineH.setAttribute('x1', element.cx - markerHalf); lineH.setAttribute('y1', element.cy); lineH.setAttribute('x2', element.cx + markerHalf); lineH.setAttribute('y2', element.cy); lineH.setAttribute('class', 'gateway-marker'); svg.appendChild(lineH); const lineV = document.createElementNS('http://www.w3.org/2000/svg', 'line'); lineV.setAttribute('x1', element.cx); lineV.setAttribute('y1', element.cy - markerHalf); lineV.setAttribute('x2', element.cx); lineV.setAttribute('y2', element.cy + markerHalf); lineV.setAttribute('class', 'gateway-marker'); svg.appendChild(lineV); }
        }
        function drawSyncBar(element, svg) {
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); rect.setAttribute('x', element.x); rect.setAttribute('y', element.y); rect.setAttribute('width', element.width); rect.setAttribute('height', element.height); rect.setAttribute('class', 'syncbar-rect'); svg.appendChild(rect);
        }
        function drawActorSymbol(cx, actorCenterY, svg) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g'); group.setAttribute('class', 'actor-symbol'); const head = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); head.setAttribute('cx', cx); head.setAttribute('cy', actorCenterY); head.setAttribute('r', ACTOR_HEAD_RADIUS); group.appendChild(head); const bodyY1 = actorCenterY + ACTOR_HEAD_RADIUS; const bodyY2 = bodyY1 + ACTOR_BODY_HEIGHT; const body = document.createElementNS('http://www.w3.org/2000/svg', 'line'); body.setAttribute('x1', cx); body.setAttribute('y1', bodyY1); body.setAttribute('x2', cx); body.setAttribute('y2', bodyY2); group.appendChild(body); const armY = bodyY1 + 5; const arms = document.createElementNS('http://www.w3.org/2000/svg', 'line'); arms.setAttribute('x1', cx - ACTOR_ARM_WIDTH / 2); arms.setAttribute('y1', armY); arms.setAttribute('x2', cx + ACTOR_ARM_WIDTH / 2); arms.setAttribute('y2', armY); group.appendChild(arms); const legY = bodyY2; const leg1 = document.createElementNS('http://www.w3.org/2000/svg', 'line'); leg1.setAttribute('x1', cx); leg1.setAttribute('y1', legY); leg1.setAttribute('x2', cx - ACTOR_LEG_SPREAD); leg1.setAttribute('y2', legY + ACTOR_LEG_SPREAD); group.appendChild(leg1); const leg2 = document.createElementNS('http://www.w3.org/2000/svg', 'line'); leg2.setAttribute('x1', cx); leg2.setAttribute('y1', legY); leg2.setAttribute('x2', cx + ACTOR_LEG_SPREAD); leg2.setAttribute('y2', legY + ACTOR_LEG_SPREAD); group.appendChild(leg2); svg.appendChild(group);
        }

        /** Draws an I/O/C/M Arrow & Label on the arrow path */
        function drawIoArrow(startX, startY, endX, endY, label, side, labelOffsetX, labelOffsetY, svg) {
             const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
             const dx = endX - startX; const dy = endY - startY;
             let finalEndX = endX; let finalEndY = endY;
             if (dx > 0) finalEndX -= ARROW_SIZE; if (dx < 0) finalEndX += ARROW_SIZE; if (dy > 0) finalEndY -= ARROW_SIZE; if (dy < 0) finalEndY += ARROW_SIZE;
             path.setAttribute('d', `M ${startX} ${startY} L ${finalEndX} ${finalEndY}`);
             path.setAttribute('class', 'io-arrow'); svg.appendChild(path);

             if (label) {
                 const midX = (startX + finalEndX) / 2; const midY = (startY + finalEndY) / 2;
                 const labelX = midX + labelOffsetX; const labelY = midY + labelOffsetY;
                 const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                 labelText.setAttribute('x', labelX); labelText.setAttribute('y', labelY);
                 labelText.setAttribute('class', 'io-label'); labelText.setAttribute('text-anchor', 'middle'); labelText.setAttribute('dominant-baseline', 'middle');
                 labelText.textContent = label;
                 const approxLabelWidth = label.length * 5.5; const approxLabelHeight = 12;
                 const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                 labelBg.setAttribute('x', labelX - approxLabelWidth / 2 - 2); labelBg.setAttribute('y', labelY - approxLabelHeight / 2 - 1);
                 labelBg.setAttribute('width', approxLabelWidth + 4); labelBg.setAttribute('height', approxLabelHeight + 2);
                 labelBg.setAttribute('class', 'io-label-bg');
                 svg.appendChild(labelBg); svg.appendChild(labelText);
             }
        }


        // --- Event Listener ---
        renderButton.addEventListener('click', () => {
             errorMessageDiv.classList.add('hidden'); errorMessageDiv.textContent = ''; svgContainer.innerHTML = '<svg></svg>'; const svg = svgContainer.querySelector('svg'); const markup = markupInput.value; const { data, error } = parseMarkup(markup); if (error) { console.error("Parsing Error Details:", error); errorMessageDiv.textContent = error; errorMessageDiv.classList.remove('hidden'); } else if (data) { console.log("Parsed Data (v10 Const Fix 2):", data); try { renderDiagram(data, svg); } catch (renderError) { console.error("Rendering Error Details:", renderError); errorMessageDiv.textContent = `Rendering Error: ${renderError.message}. Check console (F12) for details.`; errorMessageDiv.classList.remove('hidden'); } }
        });

        // --- Initial Render Example ---
        markupInput.value = `diagram SupplyChainExample

swimlane Suppliers "[Suppliers]" actor
  task T1 "Accept Order" icon="envelope"
  task T2 "Prepare Goods" icon="gear"
end

swimlane Logistics "[Logistics]" actor
  task T4 "Arrange Supply" icon="user"
end

context C0 "Overall Supply Process"
    input "Customer Order Details" from=left
    output "Goods Delivered" to=right
    control "Quality Standards" from=top
    mechanism "Logistics System" from=bottom
endcontext

// Connections
connect T1 -> T2
connect T2 -> C0.bottom "Goods Info" style="dashed" // Task to Context Mechanism
connect T4 -> C0.top "Supply Arrangement" // Task to Context Control
`;
        try { renderButton.click(); } catch (e) { console.error("Initial render failed:", e); errorMessageDiv.textContent = `Initial Render Error: ${e.message}. Check console (F12) for details.`; errorMessageDiv.classList.remove('hidden'); }

    </script>

</body>
</html>
